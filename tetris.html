<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Play Tetris '64 - A classic block puzzle game with retro vibes by Miska Braun" />
  <meta name="author" content="Miska Braun" />
  <title>Tetris '64 - Miska Braun</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="images/AppleTouchIcon.png">
  <meta name="theme-color" content="#ffd700">
  
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --text-primary: #ffffff;
      --text-secondary: #e0e0e0;
      --accent-primary: #ffdd00;
      --accent-secondary: rgba(0,255,180,0.18);
      --nav-bg: rgba(0, 0, 0, 0.8);
      --nav-bg-hover: rgba(0, 0, 0, 0.95);
      --card-bg: rgba(255,255,255,0.12);
      --game-bg: rgba(0, 0, 0, 0.85);
      --grid-color: rgba(255, 221, 0, 0.3);
    }

    /* Background Image Layer */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: url("images/AI_2025_Sky.png") no-repeat center center;
      background-size: cover;
      opacity: 0.82;
      z-index: -1;
      filter: grayscale(70%) blur(0.1px);
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      --mouse-x: 50%;
      --mouse-y: 50%;
      position: relative;
      overflow-x: hidden;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      background: radial-gradient(circle at var(--mouse-x) var(--mouse-y), var(--accent-secondary), transparent 60%);
      mix-blend-mode: lighten;
      transition: background 0.15s;
    }

    /* Navigation - Force vertical layout on desktop */
    nav {
      position: fixed !important;
      top: 50% !important;
      left: 0 !important;
      transform: translateY(-50%) !important;
      z-index: 1000;
      background: var(--nav-bg);
      border-radius: 0 10px 10px 0;
      padding: 1em 0.5em;
      backdrop-filter: blur(5px);
      transition: background 0.3s;
    }

    nav:hover {
      background: var(--nav-bg-hover);
    }

    nav ul {
      list-style: none !important;
      margin: 0 !important;
      padding: 0 !important;
      display: flex !important;
      flex-direction: column !important;
      gap: 1em !important;
      align-items: center !important;
    }

    nav ul li a {
      color: var(--text-primary) !important;
      text-decoration: none !important;
      font-weight: bold !important;
      writing-mode: vertical-rl !important;
      transform: rotate(180deg) !important;
      transition: all 0.3s ease !important;
      font-size: 1.85rem !important;
    }

    nav ul li a:hover {
      color: var(--accent-primary) !important;
      font-size: 1.95rem !important;
      transform: rotate(180deg) scale(1.00) !important;
    }

    nav ul li a.current-page {
      color: var(--accent-primary) !important;
      text-decoration: underline !important;
    }

    /* Game Container */
    .game-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2em;
      z-index: 1;
      position: relative;
    }

    .tetris-game {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 2em;
      max-width: 1200px;
      width: 100%;
      align-items: start;
    }

    /* Game Board */
    .game-board {
      background: var(--game-bg);
      border: 3px solid var(--accent-primary);
      border-radius: 10px;
      padding: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 30px rgba(255, 221, 0, 0.3);
    }

    #gameCanvas {
      display: block;
      background: #000;
      border: 2px solid var(--grid-color);
      image-rendering: pixelated;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
    }

    /* Side Panels */
    .side-panel {
      background: var(--card-bg);
      border: 2px solid var(--accent-primary);
      border-radius: 10px;
      padding: 1.5em;
      backdrop-filter: blur(5px);
      min-width: 200px;
    }

    .side-panel h3 {
      color: var(--accent-primary);
      margin-top: 0;
      text-align: center;
      font-size: 1.2em;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .score-display {
      font-size: 1.5em;
      text-align: center;
      margin: 0.5em 0;
      color: var(--text-primary);
    }

    .level-display {
      font-size: 1.2em;
      text-align: center;
      margin: 0.5em 0;
      color: var(--text-secondary);
    }

    /* Next Piece Preview */
    .next-piece {
      width: 120px;
      height: 120px;
      background: #000;
      border: 2px solid var(--grid-color);
      margin: 1em auto;
      position: relative;
      image-rendering: pixelated;
    }

    /* Game Controls */
    .controls {
      margin-top: 2em;
      text-align: center;
    }

    .control-button {
      background: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      padding: 0.8em 1.5em;
      margin: 0.5em;
      border-radius: 5px;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .control-button:hover {
      background: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 221, 0, 0.3);
    }

    .control-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Instructions */
    .instructions {
      margin-top: 2em;
      font-size: 0.9em;
      line-height: 1.4;
    }

    .instructions h4 {
      color: var(--accent-primary);
      margin-bottom: 0.5em;
    }

    .instructions p {
      margin: 0.3em 0;
      color: var(--text-secondary);
    }

    /* Game Over Screen */
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--game-bg);
      border: 3px solid var(--accent-primary);
      border-radius: 15px;
      padding: 2em;
      text-align: center;
      backdrop-filter: blur(15px);
      box-shadow: 0 0 50px rgba(255, 221, 0, 0.5);
      display: none;
      z-index: 100;
    }

    .game-over h2 {
      color: var(--accent-primary);
      margin-top: 0;
      font-size: 2em;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .final-score {
      font-size: 1.5em;
      margin: 1em 0;
      color: var(--text-primary);
    }

    /* Mobile Responsive - Only apply on actual mobile devices */
    @media (max-width: 768px) and (orientation: portrait), 
           (max-width: 768px) and (max-height: 600px) {
      nav {
        top: unset !important;
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        transform: none !important;
        border-radius: 10px 10px 0 0 !important;
        padding: 0.5em !important;
      }

      nav ul {
        flex-direction: row !important;
        justify-content: space-around !important;
      }

      nav ul li a {
        writing-mode: horizontal-tb !important;
        transform: none !important;
        font-size: 0.9rem !important;
      }

      nav ul li a:hover {
        transform: scale(1.15) !important;
      }

      .tetris-game {
        grid-template-columns: 1fr !important;
        grid-template-rows: auto auto auto !important;
        gap: 1em !important;
      }

      .game-container {
        padding: 1em !important;
        padding-bottom: 100px !important;
      }

      #gameCanvas {
        width: 100% !important;
        max-width: 300px !important;
        height: auto !important;
      }

      .side-panel {
        min-width: auto !important;
      }
    }

    /* Retro Effects */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .pulse {
      animation: pulse 0.5s ease-in-out;
    }

    @keyframes slideDown {
      from { transform: translateY(-20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .slide-down {
      animation: slideDown 0.3s ease-out;
    }

    /* Mobile Touch Controls */
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--game-bg);
      border-top: 2px solid var(--accent-primary);
      padding: 1em;
      z-index: 500;
      backdrop-filter: blur(10px);
    }

    .mobile-controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 0.5em;
      max-width: 300px;
      margin: 0 auto;
    }

    .mobile-btn {
      background: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      padding: 1em;
      border-radius: 8px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      user-select: none;
    }

    .mobile-btn:active {
      background: var(--text-primary);
      transform: scale(0.95);
    }

    .mobile-btn.rotate {
      grid-column: 2;
      grid-row: 1;
    }

    .mobile-btn.left {
      grid-column: 1;
      grid-row: 2;
    }

    .mobile-btn.down {
      grid-column: 2;
      grid-row: 2;
    }

    .mobile-btn.right {
      grid-column: 3;
      grid-row: 2;
    }

    .mobile-btn.drop {
      grid-column: 3;
      grid-row: 1;
    }

    @media (max-width: 768px) {
      .mobile-controls {
        display: block;
      }

      .game-container {
        padding-bottom: 120px;
      }

      .tetris-game {
        margin-bottom: 2em;
      }
    }
  </style>
</head>
<body>

  <!-- Navigation -->
  <nav>
    <ul>
      <li><a href="home.html">Home</a></li>
      <li><a href="freetime.html">Freetime</a></li>
      <li><a href="cv.html">CV/Professional</a></li>
      <li><a href="contact.html">Contact</a></li>
      <li><a href="games.html" class="current-page">Games</a></li>
    </ul>
  </nav>

  <div class="game-container">
    <div class="tetris-game">
      
      <!-- Left Panel: Stats -->
      <div class="side-panel">
        <h3>Score</h3>
        <div class="score-display" id="score">0</div>
        
        <h3>High Score</h3>
        <div class="score-display" id="highScore">0</div>
        
        <h3>Level</h3>
        <div class="level-display" id="level">1</div>
        
        <h3>Lines</h3>
        <div class="level-display" id="lines">0</div>

        <div class="instructions">
          <h4>Controls:</h4>
          <p>← → Move</p>
          <p>↓ Soft Drop</p>
          <p>↑ Rotate</p>
          <p>Space Hard Drop</p>
          <p>P Pause</p>
        </div>
      </div>

      <!-- Center: Game Board -->
      <div class="game-board">
        <canvas id="gameCanvas" width="300" height="600"></canvas>
        <div class="controls">
          <button class="control-button" id="startBtn">Start Game</button>
          <button class="control-button" id="pauseBtn" disabled>Pause</button>
          <button class="control-button" id="resetBtn">Reset</button>
        </div>
      </div>

      <!-- Right Panel: Next Piece -->
      <div class="side-panel">
        <h3>Next Piece</h3>
        <canvas id="nextCanvas" width="120" height="120" class="next-piece"></canvas>
        
        <div class="instructions">
          <h4>How to Play:</h4>
          <p>Complete horizontal lines to clear them and score points.</p>
          <p>Game speeds up as you progress through levels.</p>
          <p>Don't let the pieces reach the top!</p>
        </div>
      </div>

    </div>
  </div>

  <!-- Mobile Touch Controls -->
  <div class="mobile-controls">
    <div class="mobile-controls-grid">
      <button class="mobile-btn rotate" onclick="handleMobileInput('rotate')">↻</button>
      <button class="mobile-btn drop" onclick="handleMobileInput('drop')">⬇⬇</button>
      <button class="mobile-btn left" onclick="handleMobileInput('left')">←</button>
      <button class="mobile-btn down" onclick="handleMobileInput('down')">↓</button>
      <button class="mobile-btn right" onclick="handleMobileInput('right')">→</button>
    </div>
  </div>

  <script>
    // Game state
    let game = {
      board: [],
      currentPiece: null,
      nextPiece: null,
      score: 0,
      lines: 0,
      level: 1,
      gameRunning: false,
      gamePaused: false,
      dropTime: 0,
      dropInterval: 1000,
      lastTime: 0
    };

    // Canvas elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');

    // Game constants
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const BLOCK_SIZE = 30;

    // Tetris piece shapes
    const PIECES = [
      { // I-piece
        shape: [
          [1, 1, 1, 1]
        ],
        color: '#00f5ff'
      },
      { // O-piece
        shape: [
          [1, 1],
          [1, 1]
        ],
        color: '#ffff00'
      },
      { // T-piece
        shape: [
          [0, 1, 0],
          [1, 1, 1]
        ],
        color: '#ff00ff'
      },
      { // S-piece
        shape: [
          [0, 1, 1],
          [1, 1, 0]
        ],
        color: '#00ff00'
      },
      { // Z-piece
        shape: [
          [1, 1, 0],
          [0, 1, 1]
        ],
        color: '#ff0000'
      },
      { // J-piece
        shape: [
          [1, 0, 0],
          [1, 1, 1]
        ],
        color: '#0000ff'
      },
      { // L-piece
        shape: [
          [0, 0, 1],
          [1, 1, 1]
        ],
        color: '#ff8000'
      }
    ];

    // Initialize game
    function initGame() {
      // Create empty board
      game.board = [];
      for (let y = 0; y < BOARD_HEIGHT; y++) {
        game.board[y] = [];
        for (let x = 0; x < BOARD_WIDTH; x++) {
          game.board[y][x] = 0;
        }
      }

      // Load high score
      const savedHighScore = localStorage.getItem('tetris-high-score');
      if (savedHighScore) {
        document.getElementById('highScore').textContent = savedHighScore;
      }

      // Generate first pieces
      game.currentPiece = createPiece();
      game.nextPiece = createPiece();
      
      updateDisplay();
      drawBoard();
      drawNextPiece();
    }

    // Create a new piece
    function createPiece() {
      const pieceType = Math.floor(Math.random() * PIECES.length);
      const piece = {
        shape: PIECES[pieceType].shape,
        color: PIECES[pieceType].color,
        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(PIECES[pieceType].shape[0].length / 2),
        y: 0
      };
      return piece;
    }

    // Draw the game board
    function drawBoard() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = 'rgba(255, 221, 0, 0.1)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= BOARD_WIDTH; x++) {
        ctx.beginPath();
        ctx.moveTo(x * BLOCK_SIZE, 0);
        ctx.lineTo(x * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
        ctx.stroke();
      }
      for (let y = 0; y <= BOARD_HEIGHT; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * BLOCK_SIZE);
        ctx.lineTo(BOARD_WIDTH * BLOCK_SIZE, y * BLOCK_SIZE);
        ctx.stroke();
      }

      // Draw placed pieces
      for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          if (game.board[y][x]) {
            drawBlock(x, y, game.board[y][x]);
          }
        }
      }

      // Draw current piece
      if (game.currentPiece) {
        drawPiece(game.currentPiece);
      }
    }

    // Draw a single block
    function drawBlock(x, y, color) {
      const pixelX = x * BLOCK_SIZE;
      const pixelY = y * BLOCK_SIZE;

      // Block fill
      ctx.fillStyle = color;
      ctx.fillRect(pixelX + 1, pixelY + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);

      // Block border for 3D effect
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(pixelX + 1, pixelY + 1, BLOCK_SIZE - 2, 3);
      ctx.fillRect(pixelX + 1, pixelY + 1, 3, BLOCK_SIZE - 2);

      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(pixelX + BLOCK_SIZE - 4, pixelY + 4, 3, BLOCK_SIZE - 5);
      ctx.fillRect(pixelX + 4, pixelY + BLOCK_SIZE - 4, BLOCK_SIZE - 5, 3);
    }

    // Draw a piece
    function drawPiece(piece) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            drawBlock(piece.x + x, piece.y + y, piece.color);
          }
        }
      }
    }

    // Draw next piece preview
    function drawNextPiece() {
      if (!game.nextPiece) return;

      // Clear canvas
      nextCtx.fillStyle = '#000';
      nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

      const piece = game.nextPiece;
      const blockSize = 20;
      const offsetX = (nextCanvas.width - piece.shape[0].length * blockSize) / 2;
      const offsetY = (nextCanvas.height - piece.shape.length * blockSize) / 2;

      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            const pixelX = offsetX + x * blockSize;
            const pixelY = offsetY + y * blockSize;
            
            nextCtx.fillStyle = piece.color;
            nextCtx.fillRect(pixelX + 1, pixelY + 1, blockSize - 2, blockSize - 2);
            
            // 3D effect
            nextCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            nextCtx.fillRect(pixelX + 1, pixelY + 1, blockSize - 2, 2);
            nextCtx.fillRect(pixelX + 1, pixelY + 1, 2, blockSize - 2);
          }
        }
      }
    }

    // Check if piece can be placed at position
    function canPlacePiece(piece, newX, newY, newShape = null) {
      const shape = newShape || piece.shape;
      
      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const boardX = newX + x;
            const boardY = newY + y;
            
            // Check bounds
            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
              return false;
            }
            
            // Check collision with placed pieces
            if (boardY >= 0 && game.board[boardY][boardX]) {
              return false;
            }
          }
        }
      }
      return true;
    }

    // Move piece down
    function movePieceDown() {
      if (!game.currentPiece) return false;
      
      if (canPlacePiece(game.currentPiece, game.currentPiece.x, game.currentPiece.y + 1)) {
        game.currentPiece.y++;
        return true;
      } else {
        // Piece can't move down, place it
        placePiece();
        return false;
      }
    }

    // Move piece left
    function movePieceLeft() {
      if (!game.currentPiece) return;
      
      if (canPlacePiece(game.currentPiece, game.currentPiece.x - 1, game.currentPiece.y)) {
        game.currentPiece.x--;
      }
    }

    // Move piece right
    function movePieceRight() {
      if (!game.currentPiece) return;
      
      if (canPlacePiece(game.currentPiece, game.currentPiece.x + 1, game.currentPiece.y)) {
        game.currentPiece.x++;
      }
    }

    // Rotate piece
    function rotatePiece() {
      if (!game.currentPiece) return;
      
      // Create rotated shape
      const rotated = [];
      const shape = game.currentPiece.shape;
      
      for (let x = 0; x < shape[0].length; x++) {
        rotated[x] = [];
        for (let y = shape.length - 1; y >= 0; y--) {
          rotated[x][shape.length - 1 - y] = shape[y][x];
        }
      }
      
      if (canPlacePiece(game.currentPiece, game.currentPiece.x, game.currentPiece.y, rotated)) {
        game.currentPiece.shape = rotated;
      }
    }

    // Hard drop piece
    function hardDrop() {
      if (!game.currentPiece) return;
      
      while (movePieceDown()) {
        game.score += 2; // Bonus points for hard drop
      }
      updateDisplay();
    }

    // Place current piece on the board
    function placePiece() {
      if (!game.currentPiece) return;
      
      for (let y = 0; y < game.currentPiece.shape.length; y++) {
        for (let x = 0; x < game.currentPiece.shape[y].length; x++) {
          if (game.currentPiece.shape[y][x]) {
            const boardY = game.currentPiece.y + y;
            const boardX = game.currentPiece.x + x;
            
            if (boardY >= 0) {
              game.board[boardY][boardX] = game.currentPiece.color;
            }
          }
        }
      }
      
      // Check for completed lines
      clearLines();
      
      // Spawn next piece
      game.currentPiece = game.nextPiece;
      game.nextPiece = createPiece();
      
      // Check game over
      if (!canPlacePiece(game.currentPiece, game.currentPiece.x, game.currentPiece.y)) {
        gameOver();
      }
      
      drawNextPiece();
      updateDisplay();
    }

    // Clear completed lines
    function clearLines() {
      let linesCleared = 0;
      
      for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        let fullLine = true;
        for (let x = 0; x < BOARD_WIDTH; x++) {
          if (!game.board[y][x]) {
            fullLine = false;
            break;
          }
        }
        
        if (fullLine) {
          // Remove line and add empty line at top
          game.board.splice(y, 1);
          const emptyLine = new Array(BOARD_WIDTH).fill(0);
          game.board.unshift(emptyLine);
          
          linesCleared++;
          y++; // Check the same line again
        }
      }
      
      if (linesCleared > 0) {
        // Add score based on lines cleared
        const lineScores = [0, 40, 100, 300, 1200];
        game.score += lineScores[linesCleared] * (game.level + 1);
        game.lines += linesCleared;
        
        // Level up every 10 lines
        const newLevel = Math.floor(game.lines / 10) + 1;
        if (newLevel > game.level) {
          game.level = newLevel;
          game.dropInterval = Math.max(50, 1000 - (game.level - 1) * 50);
        }
        
        // Line clear animation effect
        canvas.classList.add('pulse');
        setTimeout(() => canvas.classList.remove('pulse'), 500);
      }
    }

    // Update display elements
    function updateDisplay() {
      document.getElementById('score').textContent = game.score;
      document.getElementById('level').textContent = game.level;
      document.getElementById('lines').textContent = game.lines;
      
      // Update high score
      const currentHighScore = parseInt(document.getElementById('highScore').textContent);
      if (game.score > currentHighScore) {
        document.getElementById('highScore').textContent = game.score;
        localStorage.setItem('tetris-high-score', game.score);
      }
    }

    // Game over
    function gameOver() {
      game.gameRunning = false;
      document.getElementById('startBtn').disabled = false;
      document.getElementById('pauseBtn').disabled = true;
      
      // Show game over message
      const gameOverDiv = document.createElement('div');
      gameOverDiv.className = 'game-over';
      gameOverDiv.innerHTML = `
        <h2>Game Over!</h2>
        <div class="final-score">Final Score: ${game.score}</div>
        <button class="control-button" onclick="this.parentElement.remove(); resetGame();">Play Again</button>
      `;
      gameOverDiv.style.display = 'block';
      document.querySelector('.game-board').appendChild(gameOverDiv);
    }

    // Game loop
    function gameLoop(time) {
      if (!game.gameRunning || game.gamePaused) {
        if (game.gameRunning) {
          requestAnimationFrame(gameLoop);
        }
        return;
      }
      
      const deltaTime = time - game.lastTime;
      game.dropTime += deltaTime;
      
      if (game.dropTime > game.dropInterval) {
        movePieceDown();
        game.dropTime = 0;
      }
      
      drawBoard();
      game.lastTime = time;
      requestAnimationFrame(gameLoop);
    }

    // Start game
    function startGame() {
      game.gameRunning = true;
      game.gamePaused = false;
      document.getElementById('startBtn').disabled = true;
      document.getElementById('pauseBtn').disabled = false;
      
      game.lastTime = 0;
      requestAnimationFrame(gameLoop);
    }

    // Pause game
    function pauseGame() {
      game.gamePaused = !game.gamePaused;
      const pauseBtn = document.getElementById('pauseBtn');
      pauseBtn.textContent = game.gamePaused ? 'Resume' : 'Pause';
    }

    // Reset game
    function resetGame() {
      game.gameRunning = false;
      game.gamePaused = false;
      game.score = 0;
      game.lines = 0;
      game.level = 1;
      game.dropInterval = 1000;
      game.dropTime = 0;
      
      document.getElementById('startBtn').disabled = false;
      document.getElementById('pauseBtn').disabled = true;
      document.getElementById('pauseBtn').textContent = 'Pause';
      
      initGame();
    }

    // Handle mobile input
    function handleMobileInput(action) {
      if (!game.gameRunning || game.gamePaused) return;
      
      switch(action) {
        case 'left':
          movePieceLeft();
          break;
        case 'right':
          movePieceRight();
          break;
        case 'down':
          movePieceDown();
          game.score += 1;
          break;
        case 'rotate':
          rotatePiece();
          break;
        case 'drop':
          hardDrop();
          break;
      }
      drawBoard();
      updateDisplay();
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (!game.gameRunning || game.gamePaused) return;
      
      switch(e.code) {
        case 'ArrowLeft':
          e.preventDefault();
          movePieceLeft();
          break;
        case 'ArrowRight':
          e.preventDefault();
          movePieceRight();
          break;
        case 'ArrowDown':
          e.preventDefault();
          movePieceDown();
          game.score += 1;
          break;
        case 'ArrowUp':
          e.preventDefault();
          rotatePiece();
          break;
        case 'Space':
          e.preventDefault();
          hardDrop();
          break;
        case 'KeyP':
          e.preventDefault();
          pauseGame();
          break;
      }
      drawBoard();
      updateDisplay();
    });

    // Button event listeners
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('pauseBtn').addEventListener('click', pauseGame);
    document.getElementById('resetBtn').addEventListener('click', resetGame);

    // Initialize game when page loads
    window.addEventListener('load', () => {
      initGame();
    });
  </script>

</body>
</html>