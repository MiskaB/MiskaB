<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="description" content="Play Tetris '64 - A classic block puzzle game with retro vibes by Miska Braun" />
  <meta name="author" content="Miska Braun" />
  <!-- v2.0 - Updated button styling -->
  <title>Tetris '64 - Miska Braun</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="images/AppleTouchIcon.png">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-title" content="Tetris '64">
  
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --text-primary: #ffffff;
      --text-secondary: #e0e0e0;
      --accent-primary: #ffdd00;
      --accent-secondary: rgba(0,255,180,0.18);
      --nav-bg: rgba(0, 0, 0, 0.8);
      --nav-bg-hover: rgba(0, 0, 0, 0.95);
      --card-bg: rgba(255,255,255,0.12);
      --game-bg: rgba(0, 0, 0, 0.85);
      --grid-color: rgba(255, 221, 0, 0.3);
    }

    /* Background Image Layer */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: url("images/AI_2025_Sky.png") no-repeat center center;
      background-size: cover;
      opacity: 0.82;
      z-index: -1;
      filter: grayscale(70%) blur(0.1px);
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      --mouse-x: 50%;
      --mouse-y: 50%;
      position: relative;
      overflow-x: hidden;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      background: radial-gradient(circle at var(--mouse-x) var(--mouse-y), var(--accent-secondary), transparent 60%);
      mix-blend-mode: lighten;
      transition: background 0.15s;
    }

    /* Navigation - Force vertical layout on desktop */
    nav {
      position: fixed !important;
      top: 50% !important;
      left: 0 !important;
      transform: translateY(-50%) !important;
      z-index: 1000;
      background: var(--nav-bg);
      border-radius: 0 10px 10px 0;
      padding: 1em 0.5em;
      backdrop-filter: blur(5px);
      transition: background 0.3s;
    }

    nav:hover {
      background: var(--nav-bg-hover);
    }

    nav ul {
      list-style: none !important;
      margin: 0 !important;
      padding: 0 !important;
      display: flex !important;
      flex-direction: column !important;
      gap: 1em !important;
      align-items: center !important;
    }

    nav ul li a {
      color: var(--text-primary) !important;
      text-decoration: none !important;
      font-weight: bold !important;
      writing-mode: vertical-rl !important;
      transform: rotate(180deg) !important;
      transition: all 0.3s ease !important;
      font-size: 1.85rem !important;
    }

    nav ul li a:hover {
      color: var(--accent-primary) !important;
      font-size: 1.95rem !important;
      transform: rotate(180deg) scale(1.00) !important;
    }

    nav ul li a.current-page {
      color: var(--accent-primary) !important;
      text-decoration: underline !important;
    }

    /* Game Container */
    .game-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 2em;
      z-index: 1;
      position: relative;
    }

    .tetris-game {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 2em;
      max-width: 1200px;
      width: 100%;
      align-items: start;
    }

    /* Game Board */
    .game-board {
      background: var(--game-bg);
      border: 3px solid var(--accent-primary);
      border-radius: 10px;
      padding: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 30px rgba(255, 221, 0, 0.3);
    }

    #gameCanvas {
      display: block;
      background: #000;
      border: 2px solid var(--grid-color);
      image-rendering: pixelated;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
      max-width: 100%;
      max-height: 100%;
    }

    /* Side Panels */
    .side-panel {
      background: var(--card-bg);
      border: 2px solid var(--accent-primary);
      border-radius: 10px;
      padding: 1.5em;
      backdrop-filter: blur(5px);
      min-width: 200px;
    }

    .side-panel h3 {
      color: var(--accent-primary);
      margin-top: 0;
      text-align: center;
      font-size: 1.2em;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .score-display {
      font-size: 1.5em;
      text-align: center;
      margin: 0.5em 0;
      color: var(--text-primary);
    }

    .level-display {
      font-size: 1.2em;
      text-align: center;
      margin: 0.5em 0;
      color: var(--text-secondary);
    }

    /* Next Piece Preview */
    .next-piece {
      width: 120px;
      height: 120px;
      background: #000;
      border: 2px solid var(--grid-color);
      margin: 1em auto;
      position: relative;
      image-rendering: pixelated;
    }

    /* Game Controls */
    .controls {
      margin-top: 2em;
      text-align: center;
    }

    .control-button {
      background: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      padding: 0.8em 1.5em;
      margin: 0.5em;
      border-radius: 5px;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .control-button:hover {
      background: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 221, 0, 0.3);
    }

    .control-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Instructions */
    .instructions {
      margin-top: 2em;
      font-size: 0.9em;
      line-height: 1.4;
    }

    .instructions h4 {
      color: var(--accent-primary);
      margin-bottom: 0.5em;
    }

    .instructions p {
      margin: 0.3em 0;
      color: var(--text-secondary);
    }

    /* Game Over Screen */
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--game-bg);
      border: 3px solid var(--accent-primary);
      border-radius: 15px;
      padding: 2em;
      text-align: center;
      backdrop-filter: blur(15px);
      box-shadow: 0 0 50px rgba(255, 221, 0, 0.5);
      display: none;
      z-index: 100;
    }

    .game-over h2 {
      color: var(--accent-primary);
      margin-top: 0;
      font-size: 2em;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .final-score {
      font-size: 1.5em;
      margin: 1em 0;
      color: var(--text-primary);
    }

    /* Mobile Responsive - Only for actual mobile devices */
    @media (max-width: 768px) and (hover: none) and (pointer: coarse) {
      body {
        overflow: hidden;
        position: fixed;
        width: 100vw;
        height: 100vh;
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      nav {
        display: none !important;
      }

      .mobile-back-btn {
        display: block !important;
      }

      .mobile-new-game-btn {
        display: block !important;
      }

      .tetris-game {
        display: flex !important;
        flex-direction: column !important;
        height: 100vh;
        height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        gap: 0 !important;
        grid-template-columns: unset !important;
        grid-template-rows: unset !important;
      }

      .game-container {
        padding: 0 !important;
        height: 100vh;
        height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .game-board {
        flex: 1;
        min-height: 0;
        padding: 0.75em 0.5em !important;
        padding-top: max(50px, calc(0.75em + env(safe-area-inset-top))) !important;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }

      #gameCanvas {
        width: auto !important;
        height: auto !important;
        max-width: calc(100vw - 3em) !important;
        max-height: calc(100% - 1em) !important;
        object-fit: contain;
      }

      .side-panel {
        display: none !important;
      }

      .controls {
        margin-top: 0.3em !important;
        margin-bottom: 0.3em !important;
        display: none !important;
      }

      .game-board {
        padding: 0.5em !important;
      }

      #gameCanvas {
        max-width: calc(100vw - 1em) !important;
        max-height: calc(100vh - 60px) !important;
      }

      .mobile-controls {
        display: block !important;
        padding: 0.3em;
        position: relative;
        bottom: auto;
        height: auto;
        flex-shrink: 0;
        border-top: 2px solid var(--accent-primary);
        background: var(--game-bg);
      }

      .mobile-controls-grid {
        gap: 0.25em;
        max-width: 100%;
      }

      .mobile-btn {
        padding: 0.5em;
        font-size: 0.9em;
      }

      .control-button {
        padding: 0.35em 0.7em !important;
        margin: 0 !important;
        font-size: 0.7em !important;
      }

      .mobile-controls-grid {
        max-width: 100%;
        gap: 0.3em;
      }

      .mobile-btn {
        padding: 0.8em;
        font-size: 1.1em;
      }

      .game-over {
        max-width: 90%;
        padding: 1.5em;
      }
    }

    /* Landscape mobile optimization - Only for actual mobile devices */
    @media (max-width: 900px) and (orientation: landscape) and (hover: none) and (pointer: coarse) {
      body {
        overflow: hidden;
        position: fixed;
        width: 100vw;
        height: 100vh;
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      }

      nav {
        display: none !important;
      }

      .mobile-back-btn {
        display: block !important;
      }

      .mobile-new-game-btn {
        display: block !important;
      }

      .game-container {
        padding: 0 !important;
        height: 100vh;
        height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
        display: flex;
        flex-direction: column;
      }

      .tetris-game {
        display: flex !important;
        flex-direction: row !important;
        height: 100%;
        gap: 0 !important;
      }

      .game-board {
        flex: 1;
        min-width: 0;
        padding: 0.5em !important;
        padding-left: max(0.5em, calc(50px + env(safe-area-inset-left))) !important;
        padding-right: max(0.5em, calc(50px + env(safe-area-inset-right))) !important;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }

      .side-panel {
        display: none !important;
      }

      #gameCanvas {
        width: auto !important;
        height: auto !important;
        max-width: calc(100% - 1em) !important;
        max-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 2em) !important;
        object-fit: contain;
      }

      .controls {
        display: none !important;
      }
    }

    /* Retro Effects */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .pulse {
      animation: pulse 0.5s ease-in-out;
    }

    @keyframes slideDown {
      from { transform: translateY(-20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .slide-down {
      animation: slideDown 0.3s ease-out;
    }

    /* Mobile Touch Controls - Hidden, using gesture-based controls */
    .mobile-controls {
      display: none !important;
    }

    .mobile-back-btn {
      position: fixed;
      top: max(10px, env(safe-area-inset-top, 10px));
      left: max(10px, env(safe-area-inset-left, 10px));
      background: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      padding: 0.5em 1em;
      border-radius: 5px;
      font-size: 0.9em;
      font-weight: bold;
      cursor: pointer;
      z-index: 1001;
      display: none;
      text-decoration: none;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .mobile-back-btn:hover {
      background: var(--text-primary);
    }

    .mobile-back-btn:active {
      transform: scale(0.95);
      background: var(--accent-primary);
    }

    .mobile-back-btn:visited {
      color: var(--bg-primary);
      background: var(--accent-primary);
    }

    .mobile-back-btn:link {
      color: var(--bg-primary);
      background: var(--accent-primary);
    }

    .mobile-new-game-btn {
      position: fixed;
      top: max(10px, env(safe-area-inset-top, 10px));
      right: max(10px, env(safe-area-inset-right, 10px));
      background: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      padding: 0.5em 1em;
      border-radius: 5px;
      font-size: 0.9em;
      font-weight: bold;
      cursor: pointer;
      z-index: 1001;
      display: none;
      text-decoration: none;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .mobile-new-game-btn:hover {
      background: var(--text-primary);
    }

    .mobile-new-game-btn:active {
      transform: scale(0.95);
      background: var(--accent-primary);
    }

    .mobile-controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 0.3em;
      max-width: 240px;
      margin: 0 auto;
    }

    .mobile-btn {
      background: var(--accent-primary);
      color: var(--bg-primary);
      border: none;
      padding: 0.6em;
      border-radius: 6px;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      user-select: none;
    }

    .mobile-btn:active {
      background: var(--text-primary);
      transform: scale(0.95);
    }

    .mobile-btn.rotate {
      grid-column: 2;
      grid-row: 1;
    }

    .mobile-btn.left {
      grid-column: 1;
      grid-row: 2;
    }

    .mobile-btn.down {
      grid-column: 2;
      grid-row: 2;
    }

    .mobile-btn.right {
      grid-column: 3;
      grid-row: 2;
    }

    .mobile-btn.drop {
      grid-column: 3;
      grid-row: 1;
    }

  </style>
</head>
<body>

  <!-- Navigation -->
  <nav>
    <ul>
      <li><a href="home.html">Home</a></li>
      <li><a href="freetime.html">Freetime</a></li>
      <li><a href="cv.html">CV/Professional</a></li>
      <li><a href="contact.html">Contact</a></li>
      <li><a href="games.html" class="current-page">Games</a></li>
    </ul>
  </nav>

  <!-- Mobile Back Button -->
  <a href="games.html" class="mobile-back-btn" style="background: #ffdd00; color: #0a0a0a; text-decoration: none;">← Games</a>
  <button class="mobile-new-game-btn" id="mobileNewGameBtn" style="background: #ffdd00; color: #0a0a0a;">New Game</button>

  <div class="game-container">
    <div class="tetris-game">
      
      <!-- Left Panel: Stats -->
      <div class="side-panel">
        <h3>Score</h3>
        <div class="score-display" id="score">0</div>
        
        <h3>High Score</h3>
        <div class="score-display" id="highScore">0</div>
        
        <h3>Level</h3>
        <div class="level-display" id="level">1</div>
        
        <h3>Lines</h3>
        <div class="level-display" id="lines">0</div>

        <div class="instructions">
          <h4>Controls:</h4>
          <p>← → Move</p>
          <p>↓ Soft Drop</p>
          <p>↑ Rotate</p>
          <p>Space Hard Drop</p>
          <p>P Pause</p>
        </div>
      </div>

      <!-- Center: Game Board -->
      <div class="game-board">
        <canvas id="gameCanvas" width="300" height="600"></canvas>
        <div class="controls">
          <button class="control-button" id="startBtn">Start Game</button>
          <button class="control-button" id="pauseBtn" disabled>Pause</button>
          <button class="control-button" id="resetBtn">Reset</button>
        </div>
      </div>

      <!-- Right Panel: Next Piece -->
      <div class="side-panel">
        <h3>Next Piece</h3>
        <canvas id="nextCanvas" width="120" height="120" class="next-piece"></canvas>
        
        <div class="instructions">
          <h4>How to Play:</h4>
          <p>Complete horizontal lines to clear them and score points.</p>
          <p>Game speeds up as you progress through levels.</p>
          <p>Don't let the pieces reach the top!</p>
        </div>
      </div>

    </div>
  </div>

  <script>
    // Detect mobile and screen size
    let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   (('ontouchstart' in window) && window.matchMedia('(hover: none) and (pointer: coarse)').matches);
    
    // Game state
    let game = {
      board: [],
      currentPiece: null,
      nextPiece: null,
      score: 0,
      lines: 0,
      level: 1,
      gameRunning: false,
      gamePaused: false,
      dropTime: 0,
      dropInterval: 1000,
      lastTime: 0
    };

    // Canvas elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');

    // Game constants
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    let BLOCK_SIZE = 30;
    
    // Dynamic canvas sizing for mobile
    function resizeCanvas() {
      // Only apply mobile sizing if truly a mobile/touch device
      const isTouchDevice = ('ontouchstart' in window) && window.matchMedia('(hover: none) and (pointer: coarse)').matches;
      
      if (isTouchDevice) {
        // Mobile: calculate based on actual viewport and safe areas
        
        // Account for mobile buttons (top back/new game buttons ~50px) and padding
        const topReserved = 60; // Mobile buttons + padding
        const bottomReserved = 10; // Bottom padding
        const horizontalPadding = 48; // Left/right padding (3em)
        
        // Calculate available space
        const availableWidth = window.innerWidth - horizontalPadding;
        const availableHeight = window.innerHeight - topReserved - bottomReserved;
        
        // Calculate block size to fit the board perfectly
        const blockSizeByWidth = Math.floor(availableWidth / BOARD_WIDTH);
        const blockSizeByHeight = Math.floor(availableHeight / BOARD_HEIGHT);
        
        // Use the smaller dimension to ensure everything fits, cap at 30px for larger devices
        BLOCK_SIZE = Math.min(blockSizeByWidth, blockSizeByHeight, 30);
        
        // Ensure minimum block size for playability
        BLOCK_SIZE = Math.max(BLOCK_SIZE, 12);
        
        canvas.width = BOARD_WIDTH * BLOCK_SIZE;
        canvas.height = BOARD_HEIGHT * BLOCK_SIZE;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
      } else {
        // Desktop: keep default size
        BLOCK_SIZE = 30;
        canvas.width = BOARD_WIDTH * BLOCK_SIZE;
        canvas.height = BOARD_HEIGHT * BLOCK_SIZE;
        canvas.style.width = (BOARD_WIDTH * BLOCK_SIZE) + 'px';
        canvas.style.height = (BOARD_HEIGHT * BLOCK_SIZE) + 'px';
      }
      
      // Redraw if game is running
      if (game.gameRunning) {
        drawBoard();
      }
    }
    
    // Initial resize and add listeners
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 100);
    });

    // Tetris piece shapes
    const PIECES = [
      { // I-piece
        shape: [
          [1, 1, 1, 1]
        ],
        color: '#00f5ff'
      },
      { // O-piece
        shape: [
          [1, 1],
          [1, 1]
        ],
        color: '#ffff00'
      },
      { // T-piece
        shape: [
          [0, 1, 0],
          [1, 1, 1]
        ],
        color: '#ff00ff'
      },
      { // S-piece
        shape: [
          [0, 1, 1],
          [1, 1, 0]
        ],
        color: '#00ff00'
      },
      { // Z-piece
        shape: [
          [1, 1, 0],
          [0, 1, 1]
        ],
        color: '#ff0000'
      },
      { // J-piece
        shape: [
          [1, 0, 0],
          [1, 1, 1]
        ],
        color: '#0000ff'
      },
      { // L-piece
        shape: [
          [0, 0, 1],
          [1, 1, 1]
        ],
        color: '#ff8000'
      }
    ];

    // Initialize game
    function initGame() {
      // Create empty board
      game.board = [];
      for (let y = 0; y < BOARD_HEIGHT; y++) {
        game.board[y] = [];
        for (let x = 0; x < BOARD_WIDTH; x++) {
          game.board[y][x] = 0;
        }
      }

      // Load high score
      const savedHighScore = localStorage.getItem('tetris-high-score');
      if (savedHighScore) {
        document.getElementById('highScore').textContent = savedHighScore;
      }

      // Generate first pieces
      game.currentPiece = createPiece();
      game.nextPiece = createPiece();
      
      updateDisplay();
      drawBoard();
      drawNextPiece();
    }

    // Create a new piece
    function createPiece() {
      const pieceType = Math.floor(Math.random() * PIECES.length);
      const piece = {
        shape: PIECES[pieceType].shape,
        color: PIECES[pieceType].color,
        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(PIECES[pieceType].shape[0].length / 2),
        y: 0
      };
      return piece;
    }

    // Draw the game board
    function drawBoard() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = 'rgba(255, 221, 0, 0.1)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= BOARD_WIDTH; x++) {
        ctx.beginPath();
        ctx.moveTo(x * BLOCK_SIZE, 0);
        ctx.lineTo(x * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
        ctx.stroke();
      }
      for (let y = 0; y <= BOARD_HEIGHT; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * BLOCK_SIZE);
        ctx.lineTo(BOARD_WIDTH * BLOCK_SIZE, y * BLOCK_SIZE);
        ctx.stroke();
      }

      // Draw placed pieces
      for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          if (game.board[y][x]) {
            drawBlock(x, y, game.board[y][x]);
          }
        }
      }

      // Draw current piece
      if (game.currentPiece) {
        drawPiece(game.currentPiece);
      }
    }

    // Draw a single block
    function drawBlock(x, y, color) {
      const pixelX = x * BLOCK_SIZE;
      const pixelY = y * BLOCK_SIZE;

      // Block fill
      ctx.fillStyle = color;
      ctx.fillRect(pixelX + 1, pixelY + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);

      // Block border for 3D effect
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(pixelX + 1, pixelY + 1, BLOCK_SIZE - 2, 3);
      ctx.fillRect(pixelX + 1, pixelY + 1, 3, BLOCK_SIZE - 2);

      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(pixelX + BLOCK_SIZE - 4, pixelY + 4, 3, BLOCK_SIZE - 5);
      ctx.fillRect(pixelX + 4, pixelY + BLOCK_SIZE - 4, BLOCK_SIZE - 5, 3);
    }

    // Draw a piece
    function drawPiece(piece) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            drawBlock(piece.x + x, piece.y + y, piece.color);
          }
        }
      }
    }

    // Draw next piece preview
    function drawNextPiece() {
      if (!game.nextPiece) return;

      // Clear canvas
      nextCtx.fillStyle = '#000';
      nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

      const piece = game.nextPiece;
      const blockSize = 20;
      const offsetX = (nextCanvas.width - piece.shape[0].length * blockSize) / 2;
      const offsetY = (nextCanvas.height - piece.shape.length * blockSize) / 2;

      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            const pixelX = offsetX + x * blockSize;
            const pixelY = offsetY + y * blockSize;
            
            nextCtx.fillStyle = piece.color;
            nextCtx.fillRect(pixelX + 1, pixelY + 1, blockSize - 2, blockSize - 2);
            
            // 3D effect
            nextCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            nextCtx.fillRect(pixelX + 1, pixelY + 1, blockSize - 2, 2);
            nextCtx.fillRect(pixelX + 1, pixelY + 1, 2, blockSize - 2);
          }
        }
      }
    }

    // Check if piece can be placed at position
    function canPlacePiece(piece, newX, newY, newShape = null) {
      const shape = newShape || piece.shape;
      
      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const boardX = newX + x;
            const boardY = newY + y;
            
            // Check bounds
            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
              return false;
            }
            
            // Check collision with placed pieces
            if (boardY >= 0 && game.board[boardY][boardX]) {
              return false;
            }
          }
        }
      }
      return true;
    }

    // Move piece down
    function movePieceDown() {
      if (!game.currentPiece) return false;
      
      if (canPlacePiece(game.currentPiece, game.currentPiece.x, game.currentPiece.y + 1)) {
        game.currentPiece.y++;
        return true;
      } else {
        // Piece can't move down, place it
        placePiece();
        return false;
      }
    }

    // Move piece left
    function movePieceLeft() {
      if (!game.currentPiece) return;
      
      if (canPlacePiece(game.currentPiece, game.currentPiece.x - 1, game.currentPiece.y)) {
        game.currentPiece.x--;
      }
    }

    // Move piece right
    function movePieceRight() {
      if (!game.currentPiece) return;
      
      if (canPlacePiece(game.currentPiece, game.currentPiece.x + 1, game.currentPiece.y)) {
        game.currentPiece.x++;
      }
    }

    // Rotate piece
    function rotatePiece() {
      if (!game.currentPiece) return;
      
      // Create rotated shape
      const rotated = [];
      const shape = game.currentPiece.shape;
      
      for (let x = 0; x < shape[0].length; x++) {
        rotated[x] = [];
        for (let y = shape.length - 1; y >= 0; y--) {
          rotated[x][shape.length - 1 - y] = shape[y][x];
        }
      }
      
      if (canPlacePiece(game.currentPiece, game.currentPiece.x, game.currentPiece.y, rotated)) {
        game.currentPiece.shape = rotated;
      }
    }

    // Hard drop piece
    function hardDrop() {
      if (!game.currentPiece) return;
      
      while (movePieceDown()) {
        game.score += 2; // Bonus points for hard drop
      }
      updateDisplay();
    }

    // Place current piece on the board
    function placePiece() {
      if (!game.currentPiece) return;
      
      for (let y = 0; y < game.currentPiece.shape.length; y++) {
        for (let x = 0; x < game.currentPiece.shape[y].length; x++) {
          if (game.currentPiece.shape[y][x]) {
            const boardY = game.currentPiece.y + y;
            const boardX = game.currentPiece.x + x;
            
            if (boardY >= 0) {
              game.board[boardY][boardX] = game.currentPiece.color;
            }
          }
        }
      }
      
      // Check for completed lines
      clearLines();
      
      // Spawn next piece
      game.currentPiece = game.nextPiece;
      game.nextPiece = createPiece();
      
      // Check game over
      if (!canPlacePiece(game.currentPiece, game.currentPiece.x, game.currentPiece.y)) {
        gameOver();
      }
      
      drawNextPiece();
      updateDisplay();
    }

    // Clear completed lines
    function clearLines() {
      let linesCleared = 0;
      
      for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        let fullLine = true;
        for (let x = 0; x < BOARD_WIDTH; x++) {
          if (!game.board[y][x]) {
            fullLine = false;
            break;
          }
        }
        
        if (fullLine) {
          // Remove line and add empty line at top
          game.board.splice(y, 1);
          const emptyLine = new Array(BOARD_WIDTH).fill(0);
          game.board.unshift(emptyLine);
          
          linesCleared++;
          y++; // Check the same line again
        }
      }
      
      if (linesCleared > 0) {
        // Add score based on lines cleared
        const lineScores = [0, 40, 100, 300, 1200];
        game.score += lineScores[linesCleared] * (game.level + 1);
        game.lines += linesCleared;
        
        // Level up every 10 lines
        const newLevel = Math.floor(game.lines / 10) + 1;
        if (newLevel > game.level) {
          game.level = newLevel;
          game.dropInterval = Math.max(50, 1000 - (game.level - 1) * 50);
        }
        
        // Line clear animation effect
        canvas.classList.add('pulse');
        setTimeout(() => canvas.classList.remove('pulse'), 500);
      }
    }

    // Update display elements
    function updateDisplay() {
      document.getElementById('score').textContent = game.score;
      document.getElementById('level').textContent = game.level;
      document.getElementById('lines').textContent = game.lines;
      
      // Update high score
      const currentHighScore = parseInt(document.getElementById('highScore').textContent);
      if (game.score > currentHighScore) {
        document.getElementById('highScore').textContent = game.score;
        localStorage.setItem('tetris-high-score', game.score);
      }
    }

    // Game over
    function gameOver() {
      game.gameRunning = false;
      document.getElementById('startBtn').disabled = false;
      document.getElementById('pauseBtn').disabled = true;
      
      // Show game over message
      const gameOverDiv = document.createElement('div');
      gameOverDiv.className = 'game-over';
      gameOverDiv.innerHTML = `
        <h2>Game Over!</h2>
        <div class="final-score">Final Score: ${game.score}</div>
        <button class="control-button" onclick="this.parentElement.remove(); resetGame();">Play Again</button>
      `;
      gameOverDiv.style.display = 'block';
      document.querySelector('.game-board').appendChild(gameOverDiv);
    }

    // Game loop
    function gameLoop(time) {
      if (!game.gameRunning || game.gamePaused) {
        if (game.gameRunning) {
          requestAnimationFrame(gameLoop);
        }
        return;
      }
      
      const deltaTime = time - game.lastTime;
      game.dropTime += deltaTime;
      
      if (game.dropTime > game.dropInterval) {
        movePieceDown();
        game.dropTime = 0;
      }
      
      drawBoard();
      game.lastTime = time;
      requestAnimationFrame(gameLoop);
    }

    // Start game
    function startGame() {
      game.gameRunning = true;
      game.gamePaused = false;
      document.getElementById('startBtn').disabled = true;
      document.getElementById('pauseBtn').disabled = false;
      
      game.lastTime = 0;
      requestAnimationFrame(gameLoop);
    }

    // Pause game
    function pauseGame() {
      game.gamePaused = !game.gamePaused;
      const pauseBtn = document.getElementById('pauseBtn');
      pauseBtn.textContent = game.gamePaused ? 'Resume' : 'Pause';
    }

    // Reset game
    function resetGame() {
      game.gameRunning = false;
      game.gamePaused = false;
      game.score = 0;
      game.lines = 0;
      game.level = 1;
      game.dropInterval = 1000;
      game.dropTime = 0;
      
      document.getElementById('startBtn').disabled = false;
      document.getElementById('pauseBtn').disabled = true;
      document.getElementById('pauseBtn').textContent = 'Pause';
      
      initGame();
    }

    // Touch gesture controls for mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    const SWIPE_THRESHOLD = 30;
    const TAP_TIME_THRESHOLD = 200;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      touchStartX = touch.clientX - rect.left;
      touchStartY = touch.clientY - rect.top;
      touchStartTime = Date.now();
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (!game.gameRunning || game.gamePaused) return;
      e.preventDefault();
      
      const touch = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      const touchEndX = touch.clientX - rect.left;
      const touchEndY = touch.clientY - rect.top;
      const touchEndTime = Date.now();
      
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      const deltaTime = touchEndTime - touchStartTime;
      
      // Check if it's a tap (quick touch with minimal movement)
      if (Math.abs(deltaX) < SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_THRESHOLD && deltaTime < TAP_TIME_THRESHOLD) {
        // Tap to rotate
        rotatePiece();
      } else if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        if (deltaX > SWIPE_THRESHOLD) {
          movePieceRight();
        } else if (deltaX < -SWIPE_THRESHOLD) {
          movePieceLeft();
        }
      } else if (deltaY > SWIPE_THRESHOLD) {
        // Swipe down for quick drop
        while (movePieceDown()) {
          game.score += 2;
        }
      }
      
      drawBoard();
      updateDisplay();
    }, { passive: false });

    // Prevent default touch behavior on canvas
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    // Mobile New Game button
    const mobileNewGameBtn = document.getElementById('mobileNewGameBtn');
    if (mobileNewGameBtn) {
      mobileNewGameBtn.addEventListener('click', () => {
        // Remove any game over overlay
        const gameOverDiv = document.querySelector('.game-over');
        if (gameOverDiv) gameOverDiv.remove();
        
        resetGame();
        startGame();
      });
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (!game.gameRunning || game.gamePaused) return;
      
      switch(e.code) {
        case 'ArrowLeft':
          e.preventDefault();
          movePieceLeft();
          break;
        case 'ArrowRight':
          e.preventDefault();
          movePieceRight();
          break;
        case 'ArrowDown':
          e.preventDefault();
          movePieceDown();
          game.score += 1;
          break;
        case 'ArrowUp':
          e.preventDefault();
          rotatePiece();
          break;
        case 'Space':
          e.preventDefault();
          hardDrop();
          break;
        case 'KeyP':
          e.preventDefault();
          pauseGame();
          break;
      }
      drawBoard();
      updateDisplay();
    });

    // Button event listeners
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('pauseBtn').addEventListener('click', pauseGame);
    document.getElementById('resetBtn').addEventListener('click', resetGame);

    // Initialize game when page loads
    window.addEventListener('load', () => {
      initGame();
    });
  </script>

</body>
</html>